\documentclass{article}
\usepackage{verbatim}
\usepackage[MeX]{polski}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}

\usepackage{float}

\newcommand{\tab}[1]{\hspace{.05\textwidth}\rlap{#1}}

\author{Piotr Izert, Łukasz Dragan}
\title{Algorytmy Zaawansowane - POLE}

\begin{document}

\maketitle

\newpage
\tableofcontents
\newpage


\section{Przedstawienie problemu}

\subsection{Treść zadania}
\paragraph{}\textit{
Zaprojektować i zaimplementować algorytm, który w czasie liniowym względem n oblicza pole n-wierzchołkowego prostego wielokąta oraz sprawdza, czy podany punkt leży wewnątrz tego wielokąta. Program powinien zawierać procedurę sprawdzającą, czy dany wielokąt jest prosty.
}



\section{Opis rozwiązania}

\subsection{Pole wielokąta}

\paragraph{}
W celu obliczenia pola powierzchni wielokąta prostego stosujemy algorytm wykorzystujący tzw. wzór trapezowy Gaussa \(S=\frac{1}{2}\sum\limits_{i=1}^n (x_i+x_{i+1})*(y_{i+1}-y_i)\), gdzie \(S\) to pole powierzchni wielokąta, \(x_i, y_i\ dla\ i=1...n\) to współrzędne kolejnych wierzchołków wielokąta, a \(n\) to liczba wierzchołków wielokąta. Zakładamy, że \(x_{n+1} = x_1\) oraz \(y_{n+1} = y_1\).

\paragraph{Algorytm}
%\mbox{}\\
%\(A=(x_1, y_1),..., (x_n, y_n), (x_1,y_1)\) - ciąg wierzchołków wielokąta z dodanym na koniec pierwszym wierzchołkiem.
\begin{enumerate}
\item \(area = 0\)
\item \(j=n\)
\item dla \(i=1\) do \(n\) wykonaj: %dla każdego elementu \((x_i,y_i)\) z \(A\) wykonaj:
\item \tab{\(area = area + (x_j+x_i)*(y_j-y_i)\)}
\item \tab{\(j=i\)}
\item \(area = |area/2|\)
\item RETURN \(area\)
\end{enumerate}

\paragraph{Interpretacja geometryczna} \mbox{}\\
Sumę we wzorze na pole wielokąta można interpretować jako sumę pól trapezów, z których niektóre pola wzięte są ze znakiem dodatnim, a inne z ujemnym. Zostało to zilustrowane na rysunku \ref{fig:trapez}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{trapez.png}
    \caption{Interpretacja geometryczna wzoru Gaussa na pole wielokąta}
    \label{fig:trapez}
\end{figure}

\subsection{Zawieranie punktu w wielokącie}

\paragraph{}
Sprawdzenie, czy punkt zawiera się w wielokącie jest realizowane przez zliczenie przecięć półprostej zaczynającej się w badanym punkcie z bokami wielokąta. Jeżeli liczba przecięć jest nieparzysta, to znaczy, że punkt leży wewnątrz wielokąta. W przeciwnym razie punkt leży na zewnątrz wielokąta.


W zaimplementowanym algorytmie półprosta prowadzona jest równolegle do osi X w kierunku rosnących wartości. Oznaczmy przez \(x_i, y_i\ dla\ i=1...n\) współrzędne kolejnych wierzchołków wielokąta, a przez \(X\) i \(Y\) współrzędne badanego punktu.

\paragraph{Algorytm}
\begin{enumerate}
\item inside = false
\item dla \(i=1\) do \(n\) wykonaj: 
\item \tab \tab sprawdź, czy krawędź \(i, i+1\) przecina prostą \(y=Y\)
\item \tab \tab jeżeli tak, to sprawdź, czy współrzędna x punktu przecięcia jest większa od \(X\)
\item \tab \tab jeżeli tak, to inside = !inside
\end{enumerate}

Sprawdzenie z punktu 3. realizowane jest w następujący sposób - sprawdzane jest, czy współrzędne \(y\) obydwu końców krawędzi leżą na różnych półpłaszczyznach wyznaczanych przez prostą \(y=Y\) - warunek:

$$(y_i > Y) != (y_{i+1} > Y)$$

Sprawdzenie z punktu 4. realizowane jest przez znalezienie punktu przecięcia krawędzi z prostą \(y=Y\) i porównanie go do wartości \(X\):

$$X < x_i + (x_j - x_i)\frac{y_i - Y}{y_i - y_j}$$

Przykład zasady obliczania punktu przecięcia został przedstawiony na rysunku \ref{fig:przeciecie}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{zawieranie.png}
    \caption{Sprawdzanie zawierania się punktu w wielokącie}
    \label{fig:zawieranie}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{przeciecie.png}
    \caption{Obliczanie punktu przecięcia krawędzi z prostą}
    \label{fig:przeciecie}
\end{figure}

\subsection{Sprawdzanie, czy wielokąt jest prosty}
\paragraph{}Algorytmy prezentowane w niniejszym opracowaniu mają zastosowanie jedynie, gdy dany wielokąt jest prosty.
\paragraph{Wielokąt prosty:} wielokąt, którego boki tworzą zamkniętą łamaną, a dwa jego boki mają punkt wspólny tylko, gdy są sąsiadami. (Wikipedia)
\paragraph{Algorytm}\mbox{}\\
W celu sprawdzenia, czy wielokąt jest prosty dokonujemy sprawdzenia:
\begin{enumerate}
\item czy istnieje przecięcie pomiędzy dowolnymi dwiema krawędziami $e_i$ i $e_j$ dla $|i-j|>1,\ i,j=1,...,n+1$ danego wielokąta. Przyjmujemy, iż $e_1 = e_{n+1},\ n$ - liczba krawędzi wielokąta. 
\item W przypadku $|i-j|=1$ (kolejne krawędzie wielokąta): czy jedna z krawędzi zawiera się w drugiej.
\end{enumerate}
Algorytm działa na zasadzie sprawdzenia każdej możliwej pary krawędzi $e_i,\ e_j\ dla\ j>i, i,j=1,...,n+1$. Jeżeli dla danej pary spełniony jest dowolny z warunków (1,2), wielokąt nie jest prosty.



\section{Analiza poprawności}

\subsection{Pole wielokąta}
\paragraph{Poprawność} \mbox{}\\
W pierwszej iteracji pętli z kroku 3. \(area = (x_n+x_1)*(y_n-y_1) (=(x_n+x_{n+1})*(y_n-y_{n+1}))\). W kolejnych iteracjach \(j\) jest zawsze o \(1\) mniejsze od \(i\), stąd do \(area\) dodawana jest wartość \((x_j+x_{j+1})*(y_j-y_{j+1})\ dla\ j = 1...n-1\). Stąd ostatecznie \(area = (x_n+x_{n+1})*(y_n-y_{n+1}) + (x_1+x_2)*(y_1-y_2) + ... + (x_{n-1}+x_n)*(y_{n-1}-y_{n}) = \sum\limits_{i=1}^n (x_i+x_{i+1})*(y_{i+1}-y_i)\). Po podzieleniu \(area\) przez \(2\) i wzięciu wartości bezwzględnej otrzymujemy wzór Gaussa na pole powierzchni wielokąta.


\paragraph{Złożoność czasowa} \mbox{}\\
Algorytm działa w czasie \(O(n)\), gdyż główna pętla algorytmu wykonuje dokładnie \(n\) kroków.

\subsection{Zawieranie punktu w wielokącie}


\subsection{Sprawdzanie, czy wielokąt jest prosty}

\paragraph{Poprawność} \mbox{}\\
Algorytm sprawdza pod katem przecięć wszystkie możliwe pary krawędzi, więc daje odpowiedź na pytanie, czy żadne dwie z nich nie przecinają się.

\paragraph{Złożoność czasowa} \mbox{}\\
Algorytm działa w czasie $O(n^2)$, gdyż dla krawędzi i wykonuje sprawdzenie warunków $n-i$ razy. Liczba wywołań funkcji sprawdzenia warunków $S = \sum\limits_{i=1}^n (n-i) = \frac{n(n-1)}{2}$

\section{Opis wejścia/wyjścia}

\subsection{Wejście}

\paragraph{}
Program domyślnie jako wejście przyjmuje zawartość pliku ,,in.txt'', który powinien zawierać w kolejnych liniach:
\begin{enumerate}
\item Dane postaci \(x_1\ y_1\ ...\ x_n\ y_n\), gdzie \((x_i,y_i) \in \Re^{2} \ dla\ i=1,2,...,n\) to współrzędne kolejnych punktów a \(n\) to liczba wierzchołków wielokąta.
\item Dane postaci \(x\ y\), gdzie \((x,y) \in \Re^{2}\) będące współrzędnymi punktu, którego zawieranie w wielokącie ma zostać sprawdzone.
\end{enumerate}

\paragraph{Przykładowe wejście} \mbox{}\\
\texttt{
344,8 91,2 68,8 121,6 352,8 218,4 448 114,4\\
288,8 136
}

\subsection{Wyjście}

\paragraph{}
Rezultat działania programu zapisywany jest w pliku ,,out.txt'' w postaci \(S\ Ans\) gdzie \(S\) to pole powierzchni wielokąta a \(Ans\in\{"TAK","NIE"\}\) to odpowiedź na pytanie, czy dany punkt jest zawarty w wielokącie. W przypadku, gdy dany wielokąt nie jest prosty, rezultatem działania programu jest \texttt{NOT SIMPLE}. Jeżeli dane podane na wejściu są niepoprawne, program zapisze do pliku \texttt{BAD INPUT}.

\paragraph{Przykładowe wyjście} \mbox{}\\
\texttt{1243,33 TAK}

\end{document}
